package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/sha256"
	"fmt"
	"math/big"

	"github.com/hnamzian/yehuda-mpc/party"
)

var msg = []byte("Hello, world!")

func UnsafeMPCSign(msg []byte, p1, p2 *party.Party) {
	p1.InitSignature()
	k1 := p1.GetSignature().GetMyk()
	R1 := p1.GetSignature().GetMyR()
	

	p2.InitSignature()
	k2 := p2.GetSignature().GetMyk()
	R2 := p2.GetSignature().GetMyR()

	p1.ComputeR(R2)
	// R := p1.GetSignature().GetR()

	p2.ComputeR(R1)
	// R = p2.GetSignature().GetR()

	r := p1.GetSignature().Getr()
	// r := R2.X.Mod(&R.X, elliptic.P256().Params().N)

	rd := big.NewInt(1).Mul(r, p1.PrivateKey().D)

	e := sha256.Sum256(msg)
	ebn := new(big.Int).SetBytes(e[:])

	k2Inverse := k2.ModInverse(k2, elliptic.P256().Params().N)
	k1Inverse := k1.ModInverse(k1, elliptic.P256().Params().N)
	// kInverse := new(big.Int).Mul(k1Inverse, k2Inverse)

	erd := big.NewInt(1).Add(ebn, rd)
	k2erd := big.NewInt(1).Mul(k2Inverse, erd)
	s := big.NewInt(1).Mul(k1Inverse, k2erd)
	s = s.Mod(s, elliptic.P256().Params().N)

	fmt.Printf("s: %x\n", s)
	fmt.Printf("r: %x\n", r)

	var eb []byte
	for _, b := range e {
		eb = append(eb, b)
	}

	v := ecdsa.Verify(p1.PublicKey(), eb, r, s)
	fmt.Printf("v: %v\n", v)
}

func main() {
	// 1. generate keypair for P1 (d1, Q1)
	p1 := party.NewParty()
	err := p1.GenerateKeyPair()
	if err != nil {
		panic(err)
	}
	fmt.Println("1. Generate Party1 Keypair")
	fmt.Printf("Party1 Private Key: %x\n", p1.PartyPrivateKey().D)
	fmt.Printf("Party1 Public Key: %x\n", p1.PartyPublicKey())

	// 2. generate keypair for P2 (d2, Q2)
	p2 := party.NewParty()
	err = p2.GenerateKeyPair()
	if err != nil {
		panic(err)
	}
	fmt.Println("\n2. Generate Party2 Keypair")
	fmt.Printf("Party2 Private Key: %x\n", p2.PartyPrivateKey().D)
	fmt.Printf("Party2 Public Key: %x\n", p2.PartyPublicKey())

	// 3. Calculate the keypair (d, Q) = (d1+d2, Q1+Q2)
	fmt.Println("\n3. Calculate the keypair (d, Q) = (d1+d2, Q1+Q2)")
	p1.ComputePublicKey(p2.PartyPublicKey())
	fmt.Printf("Public Key Computed by Party1: %x\n", p1.PublicKey())
	p2.ComputePublicKey(p1.PartyPublicKey())
	fmt.Printf("Public Key Computed by Party2: %x\n", p2.PublicKey())

	p1.ComputePrivateKey(p2.PartyPrivateKey())
	fmt.Printf("Private Key Computed by Party1: %x\n", p1.PrivateKey().D)
	p2.ComputePrivateKey(p1.PartyPrivateKey())
	fmt.Printf("Private Key Computed by Party2: %x\n", p2.PrivateKey().D)

	// 4. Verify that Q = d*G
	if !p1.VerifyPublicKeyIsOnCurve() {
		panic("Party1: Invalid PublicKey")
	}
	if !p2.VerifyPublicKeyIsOnCurve() {
		panic("party2: Invalid PublicKey")
	}
	fmt.Println("\n4. Verify Shared Public Key Point is on the P256 Curve (Q = d*G): OK")

	// // 5. Sign a message with d and Verify the signature with Q
	// sig_r, sig_s, err := ecdsa.Sign(rand.Reader, d, msg)
	// if err != nil {
	// 	panic(err)
	// }
	// v := ecdsa.Verify(&Q, msg, sig_r, sig_s)
	// fmt.Printf("\n5. Sign a message with d and Verify the signature with Q: %v\n", v)

	// 6a. Generate random k and compute r by Party1
	fmt.Println("\n6a. Generate random k1 and compute r1 by Party1")
	p1.InitSignature()
	// fmt.Printf("Random k1 generated by Party1: %x\n", p1.GetSignature().GetMyK())
	fmt.Printf("Computed r1 by Party1: %x\n", p1.GetSignature().GetMyR())

	// 6b. Generate random k and compute r by Party2
	fmt.Println("6b. Generate random k2 and compute r2 by Party2")
	p2.InitSignature()
	// fmt.Printf("Random k2 generated by Party2: %x\n", p2.GetSignature().GetMyK())
	fmt.Printf("Computed r2 by Party2: %x\n", p2.GetSignature().GetMyR())

	// 7a. Compute R,r by party1; R = k1*R2 and r1 = R1.x
	fmt.Println("\n7. Compute R,r by party1; R = k1*R2 and r1 = R1.x")
	p1.ComputeR(p2.GetSignature().GetMyR())
	fmt.Printf("Computed R by Party1: %x\n", p1.GetSignature().GetR())

	// 7b. Compute R,r by party2; R = k2*R1 and r2 = R2.x
	fmt.Println("7b. Compute R,r by party2; R = k2*R1 and r2 = R2.x")
	p2.ComputeR(p1.GetSignature().GetMyR())
	fmt.Printf("Computed R by Party2: %x\n", p2.GetSignature().GetR())

	// 8a. Encrypt d1 with pk1
	d1_encrypted, err := p1.EncryptPrivKey()
	if err != nil {
		panic(err)
	}
	fmt.Printf("\n8. Encrypt Party1 Private Key Enc(d1): %v\n", d1_encrypted)

	// 8b. Calculate Enc(d2)
	d2_encrypted, err := p2.EncryptPrivKey()
	if err != nil {
		panic(err)
	}
	fmt.Printf("\n8b. Encrypt Party2 Private Key Enc(d2): %v\n", d2_encrypted)

	// 9. Calculate hash of the message
	h := sha256.Sum256(msg)
	fmt.Printf("\n9. Calculate SHA256 Hash of the message: %x\n", h)

	// 10. Compute Encrypted Signature s1 by Party1
	encrypted_s1, err := p1.ComputeSigpartialS(d2_encrypted, p2.PartyPaillerPublicKey(), h[:])
	if err != nil {
		panic(err)
	}
	fmt.Printf("\n10. Compute Encrypted Signature s1 by Party1: %v\n", encrypted_s1)

	// 11. Decrypt Encrypted partial signature s2
	fmt.Println("\n11. Compute Signature R, S by Party2")
	sig_r, sig_s, err := p2.ComputeSignature(encrypted_s1)
	fmt.Printf("Computed Signature R: %x\n", sig_r)
	fmt.Printf("Computed Signature S: %x\n", sig_s)

	// 12. Verify the signature
	verified := ecdsa.Verify(p1.PublicKey(), h[:], sig_r, sig_s)
	fmt.Printf("\n12. Verify the signature: %v\n", verified)

	UnsafeMPCSign(h[:], p1, p2)

}

// func readBigIntFromFile(filename string) (*big.Int, error) {
// 	// Read the byte slice from the file
// 	data, err := ioutil.ReadFile(filename)
// 	if err != nil {
// 		return nil, err
// 	}
// 	// Convert the byte slice back to a big integer
// 	loadedBigInt := new(big.Int).SetBytes(data)
// 	return loadedBigInt, nil
// }
